<!DOCTYPE html>
<html lang="ta">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>🎵 Worship The Lord</title>

  <!-- ✅ PWA Basics -->
  <link rel="manifest" href="manifest.json" />
  <link rel="icon" href="icon-192.png" type="image/png" />
  <meta name="theme-color" content="#2c3e50" />

  <!-- ✅ Force standalone app mode on Android -->
  <meta name="mobile-web-app-capable" content="yes">

  <!-- 🔌 Optimize connection -->
  <link rel="preconnect" href="https://pub-c84190e6ff024cb9876d50ae10614e90.r2.dev" crossorigin>
  <link rel="dns-prefetch" href="https://pub-c84190e6ff024cb9876d50ae10614e90.r2.dev">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #eaf3fb;
      font-family: system-ui, sans-serif;
      text-align: center;
    }

    /* Header */
    h3 {
      color: #2c3e50;
      font-weight: 700;
      margin: 5px 0;
    }

    /* Buttons general */
    button {
      padding: 8px 14px;
      margin: 4px;
      font-size: 1rem;
      border-radius: 8px;
      border: 1px solid #bbb;
      background-color: #f8f8f8;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background-color: #eef;
    }

    #manualInstallDiv button, #shareAppDiv button {
      min-width: 150px;
    }

    /* Install buttons */
    #manualInstallDiv button,
    #installButton {
      background: linear-gradient(to bottom right, #1976d2, #0d47a1);
      color: white;
      border: none;
      font-weight: bold;
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
    }

    #manualInstallDiv button:hover,
    #installButton:hover {
      background: linear-gradient(to bottom right, #2196f3, #1565c0);
    }

    /* Share button */
    #shareAppDiv button {
      background: linear-gradient(to bottom right, #ff9800, #f57c00);
      color: white;
      border: none;
      font-weight: bold;
      box-shadow: 0 3px 6px rgba(0,0,0,0.15);
    }
    #shareAppDiv button:hover {
      background: linear-gradient(to bottom right, #ffb74d, #fb8c00);
      transform: scale(1.05);
    }

    select, button {
      padding: 6px 10px;
      margin: 4px;
      font-size: 1rem;
      border-radius: 6px;
      border: 1px solid #bbb;
    }

    #playBtn {
      background: linear-gradient(to bottom right, #4caf50, #2e7d32);
      color: white;
      border: none;
      font-weight: bold;
      font-size: 1.1rem;
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 3px 6px rgba(0,0,0,0.2);
      transition: all 0.2s ease-in-out;
    }
    #playBtn:hover {
      background: linear-gradient(to bottom right, #66bb6a, #388e3c);
      transform: scale(1.05);
    }

    #pauseBtn {
      background: linear-gradient(to bottom right, #e0e0e0, #bdbdbd);
      color: #333;
      border: none;
      font-weight: bold;
      font-size: 1.1rem;
      padding: 10px 20px;
      border-radius: 10px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.15);
      transition: all 0.2s ease-in-out;
    }
    #pauseBtn:hover {
      background: linear-gradient(to bottom right, #eeeeee, #cfcfcf);
      transform: scale(1.05);
    }

    #songSelect {
      font-size: 1rem;
      line-height: 1.4;
      white-space: pre-line;
      width: 95%;
      max-width: 400px;
    }

    /* ============================
       RESTORED OLD SEGMENT LOGIC
    ============================ */

    .segment-button {
      position: relative;
      margin: 4px;
      padding: 8px 14px;
      font-size: 1rem;
      font-weight: 500;
      color: #0d3b66;
      background: linear-gradient(to bottom right, #eaf3ff, #cfe4ff);
      border: 1px solid #a5c7f7;
      border-radius: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: all 0.25s ease;
      min-width: 90px;
      overflow: visible;
    }

    .segment-button:hover {
      background: linear-gradient(to bottom right, #d8eaff, #b9d9ff);
    }

    /* 🌟 ACTIVE GREEN HIGHLIGHT — NO MORE ZOOM (FIX APPLIED) */
    .segment-button.active {
      background: linear-gradient(to bottom right, #4caf50, #2e7d32);
      color: white;
      border: 1px solid #2e7d32;

      /* ⭐ FIX: Removed zoom to prevent flicker */
      transform: none !important;
    }

    /* GREEN PROGRESS NEEDLE */
    .progress-bar {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 3px;
      background-color: #4caf50;
      transition: left 0.05s ease-out;
      display: none;
    }
    .segment-button.active .progress-bar {
      display: block;
    }

    /* Lyrics scroll box */
    #lyricsScrollBox {
      width: 95%;
      max-width: 600px;
      height: 55vh;
      margin: 15px auto;
      padding: 12px;
      background: #fff;
      border: 2px solid #ccc;
      border-radius: 12px;
      overflow-y: auto;
      overflow-x: hidden;
      text-align: left;
    }

  </style>
</head>

<body>

<header style="margin-top:10px;">
  <h3>🎵 Worship The Lord</h3>

  <div style="display: flex; justify-content: center; gap: 10px; flex-wrap: wrap; margin-top: 8px;">
    <div id="installPrompt" style="display:none;">
      <button id="installButton">📲 Install App</button>
    </div>

    <div id="manualInstallDiv">
      <button onclick="showInstallPrompt()">📲 Install App</button>
    </div>

    <div id="shareAppDiv">
      <button onclick="shareThisApp()">📤 Share This App</button>
    </div>
  </div>
</header>


<!-- Song select -->
<div>
  <label for="songSelect" 
    style="display: inline-block; background: linear-gradient(to bottom right, #4caf50, #2e7d32);
    color: white; font-weight: bold; font-size: 1.15rem; padding: 8px 12px; border-radius: 10px;
    margin-top: 10px; box-shadow: 0 3px 6px rgba(0,0,0,0.2);">
    Select a Song <u>Below 👇</u> and Press Play, then Press Any Segment:
  </label><br>

  <select id="songSelect"></select>
</div>


<!-- Bookmark controls -->
<div style="display:inline-flex; align-items:center; gap:6px; flex-wrap:wrap; margin-top:6px;">
  <button id="bookmarkBtn"
    onclick="toggleBookmark(document.getElementById('songSelect').value)"
    style="font-size:1.4rem; border:none; background:none; cursor:pointer;">☆</button>

  <button id="bookmarkFilterBtn"
    onclick="toggleBookmarkView()"
    style="font-size:0.95rem; padding:6px 10px; border-radius:8px;">🎯 Show Bookmarked
  </button>
</div>


<!-- Player Controls -->
<div style="margin-top:10px;">
  <button id="playBtn">▶️ Play</button>
  <button id="pauseBtn">⏸️ Pause</button>
</div>

<div id="cacheStatus"></div>

<div style="margin-top:8px;">
  <button onclick="showCacheInfo()">ℹ️ Cache Info</button>
  <button onclick="clearSingleSongCache(document.getElementById('songSelect').value)">🧹 Clear Selected</button>
  <button onclick="clearAllSongCache()">🔥 Clear All Songs</button>
</div>


<!-- Volume Controls (unchanged) -->
<div class="volume-control">
  <label for="accompVolume">🏛️ Accompaniment Volume:</label>
  <button class="volume-adjust" onclick="adjustVolume('accomp', -0.01)">−</button>
  <input type="range" id="accompVolume" min="0.001" max="1" step="0.01" value="0.02">
  <span id="accompVolumeDisplay">0.02</span>
  <div style="display:flex; align-items:center; margin-left:10px;">
    <button class="volume-adjust" onclick="adjustVolume('accomp', 0.01)">+</button>
    <button onclick="toggleMute('accomp')" id="accompMuteBtn" style="margin-left:30px;">🔊 Mute</button>
  </div>
</div>

<div class="volume-control">
  <label for="vocalVolume">🎤 Vocal Volume:</label>
  <button class="volume-adjust" onclick="adjustVolume('vocal', -0.01)">−</button>
  <input type="range" id="vocalVolume" min="0.001" max="1" step="0.01" value="0.002">
  <span id="vocalVolumeDisplay">0.002</span>
  <div style="display:flex; align-items:center; margin-left:10px;">
    <button class="volume-adjust" onclick="adjustVolume('vocal', 0.01)">+</button>
    <button onclick="toggleMute('vocal')" id="vocalMuteBtn" style="margin-left:30px;">🔊 Mute</button>
  </div>
</div>



<!-- Segment Buttons -->
<div id="loopButtonsContainer"
  style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 10px; align-items: center; justify-content: center;">
</div>



<!-- Lyrics Viewer -->
<div id="lyricsScrollBox">

  <div style="margin-bottom: 10px; text-align: right; padding-right: 10px;">
    <button onclick="enableCharacterMode()" 
            style="background:#4caf50; color:white; font-weight:bold;">
      CHAR MODE
    </button>
  </div>

  <div id="tamilLyricsBox"
      style="font-size: 18px; line-height: 1.6; white-space: pre-wrap;">
  </div>

  <div id="englishLyricsBox"
      style="font-size: 16px; white-space: pre-wrap; margin-top:20px;">
  </div>

</div>



<!-- Inline JS: core hooks + progress (kept from previous working version) -->
<script>
/* Minimal app hooks (some functions intentionally left as placeholders
   because the original modular JS files are not inlined here).
   The big lyricsViewer and charMode scripts are inlined below.
*/

/* markActiveSegment + progress bar logic (restored old) */
function markActiveSegment(index) {
  const buttons = document.querySelectorAll('.segment-button');
  buttons.forEach((btn, i) => {
    btn.classList.toggle('active', i === index);
  });
}

function updateProgressBar() {
  const audio = window.vocalAudio || window.currentVocal || document.querySelector('audio');
  const buttons = document.querySelectorAll('.segment-button');
  const segments = window.currentSegments || window.loadedSegments || [];

  if (!audio || !segments || !buttons.length) {
    requestAnimationFrame(updateProgressBar);
    return;
  }

  const activeBtn = document.querySelector('.segment-button.active');
  if (activeBtn) {
    const pb = activeBtn.querySelector('.progress-bar');
    const currentTime = audio.currentTime;
    const activeSegment = segments.find(s => currentTime >= s.start && currentTime <= s.end);

    if (activeSegment && pb) {
      const percent = ((currentTime - activeSegment.start) / (activeSegment.end - activeSegment.start)) * 100;
      pb.style.left = percent + "%";
    }
  }

  requestAnimationFrame(updateProgressBar);
}

/* Hook into playSegment safely */
function hookPlaySegment() {
  if (typeof window.playSegment === "function") {
    const original = window.playSegment;
    window.playSegment = function(start, end, index) {
      if (typeof start !== "number" || typeof end !== "number") return;
      markActiveSegment(index);
      return original(start, end, index);
    };
    return true;
  }
  return false;
}

(function waitHook() {
  if (!hookPlaySegment()) {
    setTimeout(waitHook, 200);
  }
})();

requestAnimationFrame(updateProgressBar);
</script>

<!-- ============================
     INLINED: lyricsViewer.js
============================ -->
<script>
/* ===============================================================
   lyricsViewer.js  —  Character-weighted timing + whole-line highlight
   Inlined content starts here (from user-provided source)
================================================================ */

// --------- PUBLIC / GLOBALS ----------
window.lyricsData = null;              
window._lyricsProcessed = null;       
window.currentSegIndex = -1;
window.currentLineIndex = -1;

// Highlight controls
window.highlightMode = "lines";
window.highlightLines = 1;

// Manual offset globals
window.manualOffset = 0;

// === Time-lead Fix Globals (NEW) ===
// Will be set to 3.5 on new segment (optimized)
let highlightTimeLead = 0;

// === Auto-split Tunables (optimized) ===
//let targetCharsPerSplit = 35;   // optimized for smoothness & accuracy
  let targetCharsPerSplit = 50;   // optimized for smoothness & accuracy
let maxPartsLimit = 10;         // optimized cap

// Expose tunables
window.setTargetCharsPerSplit = function(n){
  const v = parseInt(n, 10);
  if (!isNaN(v) && v > 0) targetCharsPerSplit = v;
};
window.setMaxPartsLimit = function(n){
  const v = parseInt(n, 10);
  if (!isNaN(v) && v > 0) maxPartsLimit = v;
};

// Scroll control
let userIsScrolling = false;
let scrollCooldownTimer = null;
window.addEventListener('scroll', () => {
  userIsScrolling = true;
  if (scrollCooldownTimer) clearTimeout(scrollCooldownTimer);
  scrollCooldownTimer = setTimeout(() => { userIsScrolling = false; }, 5000);
});

// -------------------------
// Utility: Clean a Tamil line
// -------------------------
function cleanTamilLine(line) {
  if (!line || typeof line !== 'string') return '';
  line = line.trim();
  const allowed = /[\u0B80-\u0BFF\u00A0\u0020]/g;
  const matches = line.match(allowed);
  if (!matches) return '';
  return matches.join('').replace(/\s+/g, ' ').trim();
}

// -------------------------
// PROCESS LYRICS (Auto-Split)
// -------------------------
function processLyricsData(raw) {
  if (!raw || !Array.isArray(raw.tamilSegments)) return null;

  const processed = raw.tamilSegments.map(seg => {
    const cleanedLines = (seg.lyrics || []).map(l => cleanTamilLine(l));
    const charCounts = cleanedLines.map(l => l.length || 0);
    const totalChars = charCounts.reduce((s, v) => s + (v || 0), 0);
    const duration = (seg.end - seg.start);

    // Build cumulative
    const cumulative = [];
    let cursor = 0;
    for (let c of charCounts) {
      cumulative.push({ start: cursor, end: cursor + c });
      cursor += c;
    }

    // Auto-split
    let parts = [];
    if (totalChars <= 0 || duration <= 0) {
      parts = [{
        index: 0,
        charStart: 0,
        charEnd: Math.max(0, totalChars),
        charsInPart: Math.max(0, totalChars),
        timeStart: seg.start,
        timeEnd: seg.end,
        duration: duration,
        perChar: (totalChars > 0) ? duration / totalChars : duration
      }];
    } else {
      let partsCount = Math.ceil(totalChars / targetCharsPerSplit);
      partsCount = Math.max(1, Math.min(partsCount, Math.min(maxPartsLimit, totalChars)));

      const durationPart = duration / partsCount;

      for (let i = 0; i < partsCount; i++) {
        const cs = Math.floor(totalChars * i / partsCount);
        const ce = (i === partsCount - 1) ? totalChars : Math.floor(totalChars * (i + 1) / partsCount);
        const charsInPart = Math.max(0, ce - cs);
        const tStart = seg.start + i * durationPart;
        const tEnd = seg.start + (i + 1) * durationPart;

        parts.push({
          index: i,
          charStart: cs,
          charEnd: ce,
          charsInPart,
          timeStart: tStart,
          timeEnd: tEnd,
          duration: durationPart,
        //perChar: (charsInPart > 0) ? (durationPart / charsInPart) : durationPart

          perChar: (charsInPart > 0) ? (durationPart / charsInPart) * 0.90 : durationPart

        });
      }
    }

    return {
      start: seg.start,
      end: seg.end,
      duration,
      rawLines: seg.lyrics || [],
      cleanedLines,
      charCounts,
      totalChars,
      cumulative,
      parts
    };
  });

  return processed;
}

// -------------------------
// LOAD JSON
// -------------------------
window.loadLyricsFromJSON = function (jsonData) {
  console.log('📘 Lyrics loaded:', jsonData);
  window.lyricsData = jsonData;
  window._lyricsProcessed = processLyricsData(jsonData);
  window.currentSegIndex = -1;
  window.currentLineIndex = -1;
  window.manualOffset = 0;
  highlightTimeLead = 0;

  renderTamilLyrics();
  insertAdjustButtons();
  renderEnglishLyrics();
};

// -------------------------
// Insert offset buttons
// -------------------------
function insertAdjustButtons(){
  const box = document.getElementById('tamilLyricsBox');
  if (!box) return;

  const old = document.getElementById('lyricsAdjustButtons');
  if (old) old.remove();

  box.style.display = 'flex';
  box.style.flexDirection = 'column';
  box.style.position = 'relative';

  const btnBar = document.createElement('div');
  btnBar.id = 'lyricsAdjustButtons';

  btnBar.style.position = 'sticky';
  btnBar.style.bottom = '4px';
  btnBar.style.alignSelf = 'flex-end';
  btnBar.style.display = 'flex';
  btnBar.style.gap = '4px';
  btnBar.style.zIndex = '9999';
  btnBar.style.background = 'rgba(255,255,255,0.9)';
  btnBar.style.padding = '3px 4px';
  btnBar.style.border = '1px solid #ccc';
  btnBar.style.borderRadius = '6px';
  btnBar.style.boxShadow = '0 1px 4px rgba(0,0,0,0.15)';

  function makeBtn(label, handler){
    const b = document.createElement('button');
    b.type = 'button';
    b.textContent = label;
    b.style.fontSize = '12px';
    b.style.padding = '2px 6px';
    b.style.border = '1px solid #bbb';
    b.style.borderRadius = '4px';
    b.style.background = 'white';
    b.style.cursor = 'pointer';
    b.addEventListener('click', e => {
      e.preventDefault();
      e.stopPropagation();
      handler();
    });
    return b;
  }

  btnBar.appendChild(makeBtn('▲', () => { highlightUp(); showOffsetTooltip(); }));
  btnBar.appendChild(makeBtn('▼', () => { highlightDown(); showOffsetTooltip(); }));
  btnBar.appendChild(makeBtn('⟳', () => { highlightReset(); showOffsetTooltip(); }));

  box.appendChild(btnBar);
}

// -------------------------
// Render Tamil
// -------------------------
window.tamilRendered = [];

function renderTamilLyrics() {
  const box = document.getElementById('tamilLyricsBox');
  if (!box) return;
  box.innerHTML = '';
  window.tamilRendered = [];

  if (!window.lyricsData || !window.lyricsData.tamilSegments) return;

  window.lyricsData.tamilSegments.forEach((seg, segIndex) => {
    const segDiv = document.createElement('div');
    segDiv.style.marginBottom = '16px';

    const title = document.createElement('div');
    title.textContent = `Segment ${segIndex + 1}`;
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '6px';
    segDiv.appendChild(title);

    (seg.lyrics || []).forEach((line, lineIndex) => {
      const lineEl = document.createElement('div');
      lineEl.textContent = cleanTamilLine(line) || '\u00A0';
      lineEl.style.padding = '4px 0';
      lineEl.style.transition = 'none';
      lineEl.style.whiteSpace = 'pre-wrap';
      lineEl.style.fontSize = '16px';
      lineEl.style.fontWeight = 'normal';
      lineEl.style.color = '#333';
      lineEl.style.background = 'transparent';

      window.tamilRendered.push({ segIndex, lineIndex, el: lineEl });
      segDiv.appendChild(lineEl);
    });

    box.appendChild(segDiv);
  });
}

// -------------------------
// Render English
// -------------------------
function renderEnglishLyrics() {
  const box = document.getElementById('englishLyricsBox');
  if (!box) return;
  box.innerHTML = '';
  if (!window.lyricsData || !window.lyricsData.englishLyrics) return;
  box.textContent = window.lyricsData.englishLyrics.join('\n');
}

// -------------------------
// Scroll target line 3 lines below top
// -------------------------
function scrollToThreeLinesBelowTop(el) {
  if (!el) return;
  if (userIsScrolling) return;

  const rect = el.getBoundingClientRect();
  const lineHeight = 28;
  const offset = lineHeight * 3;
  const scrollAmount = rect.top - offset;

  window.scrollBy({ top: scrollAmount, behavior: 'smooth' });
}

// -------------------------
// Clear highlights
// -------------------------
function clearAllHighlights() {
  window.tamilRendered.forEach(item => {
    item.el.style.background = 'transparent';
    item.el.style.fontWeight = 'normal';
    item.el.style.color = '#333';
  });
}

// -------------------------
// Apply highlight
// -------------------------
function applyHighlight(segIndex, lineIndex) {
  if (segIndex === -1) {
    clearAllHighlights();
    return;
  }

  const half = Math.floor(window.highlightLines / 2);

  window.tamilRendered.forEach(item => {
    if (item.segIndex !== segIndex) {
      item.el.style.background = 'transparent';
      item.el.style.fontWeight = 'normal';
      item.el.style.color = '#333';
      return;
    }

    const rel = item.lineIndex - lineIndex;
    const within = (window.highlightLines % 2 === 1)
      ? Math.abs(rel) <= half
      : (rel >= 0 && rel < window.highlightLines);

    if (within) {
      item.el.style.background = 'rgba(255,255,0,0.35)';
      item.el.style.fontWeight = 'bold';
      item.el.style.color = '#000';

      if (rel === 0) scrollToThreeLinesBelowTop(item.el);
    } else {
      item.el.style.background = 'transparent';
      item.el.style.fontWeight = 'normal';
      item.el.style.color = '#333';
    }
  });
}

// -------------------------
// UPDATE HIGHLIGHT (Main logic)
// -------------------------
window.updateLyricsHighlight = function (currentTime) {
  if (!window._lyricsProcessed || !Array.isArray(window._lyricsProcessed)) return;

  const segments = window._lyricsProcessed;
  let segIndex = -1;

  for (let i = 0; i < segments.length; i++) {
    if (currentTime >= segments[i].start && currentTime <= segments[i].end) {
      segIndex = i;
      break;
    }
  }

  // Reset lead if new segment
  if (segIndex !== window.currentSegIndex) {
 // highlightTimeLead = 3.50;  // ⭐ optimized start value
    highlightTimeLead = 5.00;  // ⭐ optimized start value
  }

  if (segIndex === -1) {
    clearAllHighlights();
    window.currentSegIndex = -1;
    window.currentLineIndex = -1;
    return;
  }

  const seg = segments[segIndex];
  const duration = seg.duration;

  // Apply dynamic lead: 3.5 → 0.0 in steps of 0.5
  let elapsed = (currentTime - seg.start) + highlightTimeLead;
 // highlightTimeLead = Math.max(0, highlightTimeLead - 0.5);
    highlightTimeLead = Math.max(0, highlightTimeLead - 0.1);


  if (!seg.totalChars || seg.totalChars <= 0 || duration <= 0) {
    const numLines = (seg.cleanedLines || []).length || 1;
    const perLine = duration / numLines;
    let lineIndex = Math.floor(elapsed / perLine);
    if (lineIndex >= numLines) lineIndex = numLines - 1;

    const finalIndex = Math.max(0, Math.min(lineIndex + window.manualOffset, numLines - 1));
    window.currentSegIndex = segIndex;
    window.currentLineIndex = finalIndex;
    applyHighlight(segIndex, finalIndex);
    return;
  }

  // Determine part
  const parts = seg.parts;
  let partIndex = Math.floor((elapsed) / parts[0].duration);
  if (partIndex < 0) partIndex = 0;
  if (partIndex >= parts.length) partIndex = parts.length - 1;

  const part = parts[partIndex];
  let elapsedWithinPart = (seg.start + elapsed) - part.timeStart;

  if (elapsedWithinPart < 0) elapsedWithinPart = 0;
  if (elapsedWithinPart > part.duration) elapsedWithinPart = part.duration;

  let charsElapsedWithinPart = (part.charsInPart > 0)
    ? elapsedWithinPart / part.perChar
    : 0;

  let globalCharIndex = part.charStart + charsElapsedWithinPart;
  if (globalCharIndex < 0) globalCharIndex = 0;
  if (globalCharIndex >= seg.totalChars) globalCharIndex = seg.totalChars - 1;

  // Map char index → line
  let lineIndex = 0;
  for (let i = 0; i < seg.cumulative.length; i++) {
    const b = seg.cumulative[i];
    if (b.start <= globalCharIndex && globalCharIndex < b.end) {
      lineIndex = i;
      break;
    }
    if (i === seg.cumulative.length - 1 && globalCharIndex >= b.end) {
      lineIndex = i;
    }
  }

  const numLines = seg.cumulative.length;
  const requested = lineIndex + window.manualOffset;
  const finalIndex = Math.max(0, Math.min(requested, numLines - 1));

  window.currentSegIndex = segIndex;
  window.currentLineIndex = finalIndex;
  applyHighlight(segIndex, finalIndex);
};

// -------------------------
// Manual controls
// -------------------------
window.highlightUp = function(){
  const seg = (window.lyricsData && window.lyricsData.tamilSegments && window.currentSegIndex>=0)
    ? window.lyricsData.tamilSegments[window.currentSegIndex]
    : null;
  if (!seg) {
    window.manualOffset -= 1;
    return;
  }
  const autoIndex = window.currentLineIndex - window.manualOffset;
  const minOffset = -autoIndex;
  if (window.manualOffset <= minOffset) {
    showBoundaryTooltip('Top reached');
    return;
  }
  window.manualOffset -= 1;
};

window.highlightDown = function(){
  const seg = (window.lyricsData && window.lyricsData.tamilSegments && window.currentSegIndex>=0)
    ? window.lyricsData.tamilSegments[window.currentSegIndex]
    : null;
  if (!seg) {
    window.manualOffset += 1;
    return;
  }
  const autoIndex = window.currentLineIndex - window.manualOffset;
  const maxOffset = seg.lyrics.length - 1 - autoIndex;
  if (window.manualOffset >= maxOffset) {
    showBoundaryTooltip('End of segment');
    return;
  }
  window.manualOffset += 1;
};

window.highlightReset = function(){ 
  window.manualOffset = 0; 
};

// -------------------------
// Keyboard shortcuts
// -------------------------
window.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowUp') {
    highlightUp();
    showOffsetTooltip();
    e.preventDefault();
  } else if (e.key === 'ArrowDown') {
    highlightDown();
    showOffsetTooltip();
    e.preventDefault();
  } else if (e.key.toLowerCase() === 'r') {
    highlightReset();
    showOffsetTooltip();
  }
});

// -------------------------
// Tooltip
// -------------------------
let offsetTooltipEl = null;
let offsetTooltipTimer = null;

function showOffsetTooltip() {
  const box = document.getElementById('tamilLyricsBox');
  if (!box) return;

  if (!offsetTooltipEl) {
    offsetTooltipEl = document.createElement('div');
    offsetTooltipEl.style.position = 'absolute';
    offsetTooltipEl.style.top = '4px';
    offsetTooltipEl.style.right = '8px';
    offsetTooltipEl.style.fontSize = '12px';
    offsetTooltipEl.style.color = '#555';
    offsetTooltipEl.style.background = 'rgba(255,255,255,0.7)';
    offsetTooltipEl.style.padding = '2px 6px';
    offsetTooltipEl.style.borderRadius = '4px';
    offsetTooltipEl.style.pointerEvents = 'none';
    offsetTooltipEl.style.transition = 'opacity 0.4s';
    box.style.position = 'relative';
    box.appendChild(offsetTooltipEl);
  }

  const off = window.manualOffset || 0;
  offsetTooltipEl.textContent = off === 0 ? 'Offset: 0 (Sync)' : `Offset: ${off > 0 ? '+'+off : off}`;
  offsetTooltipEl.style.opacity = '1';

  if (offsetTooltipTimer) clearTimeout(offsetTooltipTimer);
  offsetTooltipTimer = setTimeout(() => {
    if (offsetTooltipEl) offsetTooltipEl.style.opacity = '0';
  }, 2000);
}

function showBoundaryTooltip(msg){
  const box = document.getElementById('tamilLyricsBox');
  if (!box) return;
  if (!offsetTooltipEl) {
    offsetTooltipEl = document.createElement('div');
    offsetTooltipEl.style.position = 'absolute';
    offsetTooltipEl.style.top = '4px';
    offsetTooltipEl.style.right = '8px';
    offsetTooltipEl.style.fontSize = '12px';
    offsetTooltipEl.style.color = '#a00';
    offsetTooltipEl.style.background = 'rgba(255,230,230,0.9)';
    offsetTooltipEl.style.padding = '2px 6px';
    offsetTooltipEl.style.borderRadius = '4px';
    offsetTooltipEl.style.pointerEvents = 'none';
    offsetTooltipEl.style.transition = 'opacity 0.4s';
    box.style.position = 'relative';
    box.appendChild(offsetTooltipEl);
  }
  offsetTooltipEl.textContent = msg;
  offsetTooltipEl.style.opacity = '1';
  if (offsetTooltipTimer) clearTimeout(offsetTooltipTimer);
  offsetTooltipTimer = setTimeout(() => { 
    if (offsetTooltipEl) offsetTooltipEl.style.opacity = '0'; 
  }, 2000);
}

// End of lyricsViewer.js inlined
</script>

<!-- ============================
     INLINED: lyricsViewer_charMode.js
============================ -->
<script>
/* ===============================================================
   lyricsViewer_charMode.js  (GOLD — Optimized: chunks=5 + smoothing + RAF)
   Inlined content starts here (from user-provided source)
================================================================ */

// CONFIG
window.charMode = window.charMode || {};
window.charMode.countSpaces = true;
window.charMode.stepChars = 5;
window.charMode.chunkSize = 5; // higher resolution
window.charMode.smoothingFactor = 0.90; // <1 slows start, >1 speeds start; 0.85 recommended
window.charMode.scrollThreshold = 3; // scroll only when highlighted index moved by >= this
window.charMode.highlightClass = 'charmode-highlight';
window.charMode.normalClass = 'charmode-normal';

// STATE
window.charModeEnabled = false;
window.manualCharOffsetChars = 0;
window._charRenderedSpans = null;
window._charTooltipEl = null;
window._charTooltipTimer = null;
window._charGlobal = {
  chars: [],
  totalChars: 0,
  totalLyricsSeconds: 0,
  segments: []
};

// PERF caches
window._charSpanByGidx = null; // array mapping gidx -> span (or null)
window._charPrevHighlightedIndex = 0;
window._charRAFId = null;

// inject fast CSS classes once
(function _ensureCharModeStyles() {
  if (document.getElementById('charModeInjectedStyles')) return;
  const style = document.createElement('style');
  style.id = 'charModeInjectedStyles';
  style.textContent = `
    .${window.charMode.highlightClass} {
      background: rgba(255,255,0,0.35) !important;
      color: #000 !important;
      font-weight: bold !important;
    }
    .${window.charMode.normalClass} {
      background: transparent !important;
      color: #333 !important;
      font-weight: normal !important;
    }
  `;
  document.head && document.head.appendChild(style);
})();

// --------------------------------------------------------------
// Clean Tamil line (preserve Tamil range + NBSP + space)
// --------------------------------------------------------------
function _char_cleanTamilLine(line) {
  if (typeof cleanTamilLine === 'function') return cleanTamilLine(line);
  if (!line || typeof line !== 'string') return '';
  const m = line.match(/[\u0B80-\u0BFF\u00A0\u0020]/g);
  if (!m) return '';
  return m.join('').replace(/\s+/g, ' ').trim();
}

// --------------------------------------------------------------
// Build global character array AND compute per-segment chunks
// --------------------------------------------------------------
function buildGlobalCharArray() {
  const raw = window.lyricsData;
  if (!raw || !Array.isArray(raw.tamilSegments)) {
    window._charGlobal = { chars: [], totalChars: 0, totalLyricsSeconds: 0, segments: [] };
    return;
  }

  const chars = [];
  const segments = [];
  let gCounted = 0;

  const firstStart = raw.tamilSegments.length ? raw.tamilSegments[0].start : 0;
  const lastEnd = raw.tamilSegments.length ? raw.tamilSegments[raw.tamilSegments.length - 1].end : firstStart;
  const totalLyricsSeconds = Math.max(0, lastEnd - firstStart);

  raw.tamilSegments.forEach((seg, segIndex) => {
    const segStart = (typeof seg.start === 'number') ? seg.start : 0;
    const segEnd = (typeof seg.end === 'number') ? seg.end : segStart;
    const segDuration = Math.max(0, segEnd - segStart);

    const segEntry = {
      start: segStart,
      end: segEnd,
      duration: segDuration,
      startGidx: gCounted,
      totalChars: 0,
      chunks: [],
      lineBounds: []
    };

    (seg.lyrics || []).forEach((line, lineIndex) => {
      const cleaned = _char_cleanTamilLine(line) || '\u00A0';
      const startG = gCounted;

      for (let li = 0; li < cleaned.length; li++) {
        const ch = cleaned[li];
        const counts = !(ch === ' ' && !window.charMode.countSpaces);

        chars.push({
          ch,
          segIndex,
          lineIndex,
          localIndex: li,
          countedIndex: counts ? gCounted : null,
          countsTowardsTotal: counts
        });

        if (counts) gCounted++;
      }

      const endG = gCounted;
      segEntry.lineBounds.push({ segIndex, lineIndex, startGidx: startG, endGidx: endG, cleaned });
    });

    segEntry.totalChars = gCounted - segEntry.startGidx;

    // chunking by character count (fixed-size chunks)
    const chunkSize = Math.max(1, parseInt(window.charMode.chunkSize || 5, 10));
    const total = segEntry.totalChars;
    const numChunks = total > 0 ? Math.max(1, Math.ceil(total / chunkSize)) : 1;
    const baseChunkDuration = numChunks > 0 ? (segEntry.duration / numChunks) : Infinity;

    for (let c = 0; c < numChunks; c++) {
      const cStart = segEntry.startGidx + c * chunkSize;
      const cEnd = Math.min(segEntry.startGidx + (c + 1) * chunkSize, segEntry.startGidx + total);
      const cChars = Math.max(0, cEnd - cStart);
      const cDur = baseChunkDuration;
      const secondsPerChar = cChars > 0 ? (cDur / cChars) : Infinity;
      segEntry.chunks.push({ startGidx: cStart, endGidx: cEnd, totalChars: cChars, duration: cDur, secondsPerChar });
    }

    segments.push(segEntry);
  });

  window._charGlobal = { chars, totalChars: gCounted, totalLyricsSeconds, segments };

  // build fast spanByGidx cache placeholder (filled after render)
  window._charSpanByGidx = new Array(Math.max(0, gCounted));
  for (let i = 0; i < window._charSpanByGidx.length; i++) window._charSpanByGidx[i] = null;
}

// --------------------------------------------------------------
// Render Tamil lyrics with each character wrapped in spans
// (DOM mapping unchanged — keep data-gidx global)
// After render, build spanByGidx cache for O(1) access
// --------------------------------------------------------------
function renderTamilLyricsCharMode() {
  const box = document.getElementById("tamilLyricsBox");
  if (!box) return;
  box.innerHTML = "";
  window._charRenderedSpans = null;
  window._charSpanByGidx = window._charSpanByGidx || [];

  const raw = window.lyricsData;
  if (!raw || !Array.isArray(raw.tamilSegments)) return;

  raw.tamilSegments.forEach((seg, segIndex) => {
    const segDiv = document.createElement('div');
    segDiv.style.marginBottom = "16px";

    const title = document.createElement('div');
    title.textContent = `Segment ${segIndex + 1}`;
    title.style.fontWeight = 'bold';
    title.style.marginBottom = '6px';
    segDiv.appendChild(title);

    (seg.lyrics || []).forEach((line) => {
      const lineEl = document.createElement('div');
      lineEl.style.padding = '4px 0';
      lineEl.style.whiteSpace = 'pre-wrap';
      lineEl.style.fontSize = '16px';
      lineEl.style.color = '#333';

      const cleaned = _char_cleanTamilLine(line) || '\u00A0';
      for (let i = 0; i < cleaned.length; i++) {
        const span = document.createElement('span');
        span.textContent = cleaned[i];
        span.setAttribute('data-gidx', '');
        span.classList.add(window.charMode.normalClass || 'charmode-normal');
        lineEl.appendChild(span);
      }

      segDiv.appendChild(lineEl);
    });

    box.appendChild(segDiv);
  });

  // map chars -> spans (preserve mapping behavior)
  const spanList = box.querySelectorAll('span');
  let cursor = 0;
  const gchars = window._charGlobal.chars || [];

  for (let ci = 0; ci < gchars.length; ci++) {
    const entry = gchars[ci];

    while (cursor < spanList.length) {
      const s = spanList[cursor];
      const has = s.getAttribute('data-gidx');
      if (has && has.length) {
        cursor++;
        continue;
      }
      if (entry.countsTowardsTotal) {
        const gidx = String(entry.countedIndex);
        s.setAttribute('data-gidx', gidx);
        // cache into spanByGidx
        if (entry.countedIndex !== null && typeof entry.countedIndex === 'number') {
          window._charSpanByGidx[entry.countedIndex] = s;
        }
      }
      cursor++;
      break;
    }
  }

  // Safety: ensure spanByGidx length matches totalChars
  if (Array.isArray(window._charSpanByGidx) && window._charSpanByGidx.length !== window._charGlobal.totalChars) {
    const old = window._charSpanByGidx;
    window._charSpanByGidx = new Array(Math.max(0, window._charGlobal.totalChars));
    for (let i = 0; i < window._charSpanByGidx.length; i++) window._charSpanByGidx[i] = old[i] || null;
  }

  window._charRenderedSpans = spanList;
}

// --------------------------------------------------------------
// Apply highlight changes — optimized to update only changed spans
// --------------------------------------------------------------
function applyCharHighlightOptimized(newIndex) {
  // newIndex is integer target; prevIndex may be fractional stored as prev floor
  const prev = Math.floor(window._charPrevHighlightedIndex || 0);
  const cur = Math.floor(newIndex);

  if (prev === cur) return; // nothing changed

  const spanByGidx = window._charSpanByGidx || [];
  // determine dirty range (min..max exclusive of upper bound)
  const start = Math.min(prev, cur);
  const end = Math.max(prev, cur);

  // If highlight moved forward, mark newly highlighted spans
  if (cur > prev) {
    for (let i = start; i < end; i++) {
      const sp = spanByGidx[i];
      if (!sp) continue;
      // only update if not already highlighted
      if (!sp.classList.contains(window.charMode.highlightClass)) {
        sp.classList.remove(window.charMode.normalClass);
        sp.classList.add(window.charMode.highlightClass);
      }
    }
  } else {
    // moved backward: un-highlight spans in [cur, prev)
    for (let i = start; i < end; i++) {
      const sp = spanByGidx[i];
      if (!sp) continue;
      if (!sp.classList.contains(window.charMode.normalClass)) {
        sp.classList.remove(window.charMode.highlightClass);
        sp.classList.add(window.charMode.normalClass);
      }
    }
  }

  window._charPrevHighlightedIndex = cur;
}

// Fallback for older code paths (keeps external contract)
function applyCharHighlight(finalCountIndex) {
  // Use optimized path if cache available
  if (Array.isArray(window._charSpanByGidx) && window._charSpanByGidx.length) {
    applyCharHighlightOptimized(finalCountIndex);
    return;
  }

  // otherwise full scan (legacy)
  if (!window._charRenderedSpans) return;
  for (const s of window._charRenderedSpans) {
    const v = s.getAttribute('data-gidx');
    if (!v) {
      s.classList.remove(window.charMode.highlightClass);
      s.classList.add(window.charMode.normalClass);
      continue;
    }
    const gidx = parseInt(v, 10);
    if (gidx < finalCountIndex) {
      s.classList.remove(window.charMode.normalClass);
      s.classList.add(window.charMode.highlightClass);
    } else {
      s.classList.remove(window.charMode.highlightClass);
      s.classList.add(window.charMode.normalClass);
    }
  }
}

// --------------------------------------------------------------
// Scroll support — lazy scrolling (only when moved enough)
// --------------------------------------------------------------
function scrollToCharIndexLazy(finalCountIndex) {
  if (!window._charRenderedSpans) return;

  const prev = Math.floor(window._charPrevScrollIndex || 0);
  const cur = Math.floor(finalCountIndex);
  const threshold = window.charMode.scrollThreshold || 3;
  if (Math.abs(cur - prev) < threshold) {
    // do not scroll
    return;
  }

  // find the last highlighted span (cur - 1)
  const targetIdx = Math.max(0, cur - 1);
  const sp = (window._charSpanByGidx && window._charSpanByGidx[targetIdx]) || null;
  if (!sp) return;

  const rect = sp.getBoundingClientRect();
  const offset = 28 * 3;
  const scrollAmount = rect.top - offset;

  const box = document.getElementById('tamilLyricsBox');
  if (box) {
    box.scrollTop += scrollAmount;
    window._charPrevScrollIndex = cur;
  }
}

// --------------------------------------------------------------
// Main per-frame engine (uses smoothing, chunks, clamp B1)
// --------------------------------------------------------------
function _computeGlobalIndexFromTime(currentTime) {
  const g = window._charGlobal;
  if (!g || !Array.isArray(g.segments) || g.segments.length === 0) return 0;
  if (typeof g.totalChars !== 'number') g.totalChars = (g.chars || []).reduce((acc, e) => acc + (e.countsTowardsTotal ? 1 : 0), 0);

  const segments = g.segments;
  // find last segment whose start <= currentTime
  let segIndex = -1;
  for (let i = 0; i < segments.length; i++) {
    if (currentTime >= segments[i].start) segIndex = i;
    else break;
  }
  if (segIndex === -1) return 0;

  const seg = segments[segIndex];
  const segStart = seg.start;
  const segEnd = seg.end;

  if (!seg.totalChars || seg.totalChars <= 0) return seg.startGidx;

  // If time beyond segment end: clamp to last char of this segment (B1)
  if (currentTime > segEnd) {
    return seg.startGidx + seg.totalChars;
  }

  // inside segment -> map to chunk
  const rel = Math.max(0, currentTime - segStart);
  const numChunks = Math.max(1, seg.chunks.length);
  const chunkDuration = seg.duration / numChunks;

  // chunk index
  let chunkIndex = Math.floor(rel / (chunkDuration || 1e-9));
  if (chunkIndex < 0) chunkIndex = 0;
  if (chunkIndex >= numChunks) chunkIndex = numChunks - 1;

  const chunk = seg.chunks[chunkIndex];
  const chunkStartTime = chunkIndex * chunkDuration;
  const relInChunk = Math.max(0, rel - chunkStartTime);

  // base local index inside chunk using secondsPerChar
  let baseLocal = 0;
  if (!isFinite(chunk.secondsPerChar) || chunk.secondsPerChar <= 0) {
    baseLocal = 0;
  } else {
    baseLocal = relInChunk / chunk.secondsPerChar;
  }

  // apply curvature smoothing per-segment optionally
  const smoothing = typeof window.charMode.smoothingFactor === 'number' ? window.charMode.smoothingFactor : 1.0;
  // smoothing acts on normalized progress within the chunk (0..1)
  let normalized = 0;
  if (chunk.totalChars > 0) {
    normalized = Math.max(0, Math.min(1, baseLocal / chunk.totalChars));
    // apply power curve, keep result in [0,1]
    if (smoothing > 0 && smoothing !== 1) {
      normalized = Math.pow(normalized, smoothing);
    }
    baseLocal = normalized * chunk.totalChars;
  }

  const localClamped = Math.max(0, Math.min(baseLocal, chunk.totalChars));
  const globalIndex = chunk.startGidx + Math.floor(localClamped);
  return globalIndex;
}

// RAF loop
function _charModeFrameLoop() {
  if (!window.charModeEnabled) {
    window._charRAFId = null;
    return;
  }

  const ct = (window.vocalAudio && typeof window.vocalAudio.currentTime === 'number') ? window.vocalAudio.currentTime : 0;
  // compute raw global index
  const rawIndex = _computeGlobalIndexFromTime(ct);
  // apply manual offset
  const offsetApplied = rawIndex + (window.manualCharOffsetChars || 0);
  // clamp
  const limited = Math.max(0, Math.min(offsetApplied, (window._charGlobal.totalChars || 0)));

  // optimized apply
  applyCharHighlightOptimized(Math.floor(limited));
  scrollToCharIndexLazy(Math.floor(limited));
  window.currentGlobalCharIndex = limited;

  // schedule next frame
  window._charRAFId = window.requestAnimationFrame(_charModeFrameLoop);
}

// --------------------------------------------------------------
// Enable / Disable (start / stop RAF loop)
// --------------------------------------------------------------
window.enableCharacterMode = function () {
  window.charModeEnabled = true;
  window.manualCharOffsetChars = 0;

  buildGlobalCharArray();
  renderTamilLyricsCharMode();

  const box = document.getElementById("tamilLyricsBox");
  if (box) window._charRenderedSpans = box.querySelectorAll('span');

  // reset caches/state
  window._charPrevHighlightedIndex = 0;
  window._charPrevScrollIndex = 0;

  // start RAF loop
  if (!window._charRAFId) {
    window._charRAFId = window.requestAnimationFrame(_charModeFrameLoop);
  }

  // show controls
  _char_insertAdjustButtons();
};

window.disableCharacterMode = function () {
  window.charModeEnabled = false;
  if (window._charRAFId) {
    window.cancelAnimationFrame(window._charRAFId);
    window._charRAFId = null;
  }
  const old = document.getElementById("charModeAdjustButtons");
  if (old) old.remove();
  if (typeof renderTamilLyrics === 'function') renderTamilLyrics();
};

// --------------------------------------------------------------
// Controls (unchanged behavior)
// --------------------------------------------------------------
window.charStepForward = function () {
  window.manualCharOffsetChars += window.charMode.stepChars;
  _char_showOffsetTooltip();
};

window.charStepBackward = function () {
  window.manualCharOffsetChars -= window.charMode.stepChars;
  _char_showOffsetTooltip();
};

window.charStepReset = function () {
  window.manualCharOffsetChars = 0;
  _char_showOffsetTooltip();
};

// --------------------------------------------------------------
// Buttons & Tooltip (unchanged, small cosmetics preserved)
// --------------------------------------------------------------
function _char_insertAdjustButtons() {
  const box = document.getElementById("tamilLyricsBox");
  if (!box) return;

  const old = document.getElementById("charModeAdjustButtons");
  if (old) old.remove();

  const bar = document.createElement("div");
  bar.id = "charModeAdjustButtons";
  bar.style.position = "sticky";
  bar.style.bottom = "4px";
  bar.style.alignSelf = "flex-end";
  bar.style.display = "flex";
  bar.style.gap = "4px";
  bar.style.background = "white";
  bar.style.padding = "4px";
  bar.style.border = "1px solid #ccc";
  bar.style.borderRadius = "6px";
  bar.style.zIndex = "9999";

  function btn(t, f) {
    const b = document.createElement("button");
    b.textContent = t;
    b.style.fontSize = "12px";
    b.style.padding = "2px 6px";
    b.onclick = f;
    return b;
  }

  bar.appendChild(btn("▲", () => charStepBackward()));
  bar.appendChild(btn("▼", () => charStepForward()));
  bar.appendChild(btn("⟳", () => charStepReset()));

  const tgl = btn("LINE", () => {
    disableCharacterMode();
  });
  tgl.style.background = "#32cd32";

  bar.appendChild(tgl);
  box.appendChild(bar);
}

function _char_showOffsetTooltip() {
  const box = document.getElementById('tamilLyricsBox');
  if (!box) return;

  if (!window._charTooltipEl) {
    const t = document.createElement('div');
    t.style.position = 'absolute';
    t.style.top = '4px';
    t.style.right = '8px';
    t.style.padding = '3px 6px';
    t.style.background = 'white';
    t.style.border = '1px solid #ccc';
    t.style.fontSize = '12px';
    t.style.opacity = '0.9';
    box.appendChild(t);
    window._charTooltipEl = t;
  }

  const off = window.manualCharOffsetChars;
  window._charTooltipEl.textContent = `Offset: ${off >= 0 ? "+"+off : off}`;

  if (window._charTooltipTimer) clearTimeout(window._charTooltipTimer);
  window._charTooltipTimer = setTimeout(() => {
    if (window._charTooltipEl) window._charTooltipEl.remove();
    window._charTooltipEl = null;
  }, 2000);
}

window.addEventListener('keydown', (e) => {
  if (!window.charModeEnabled) return;
  if (e.key === "ArrowRight") { charStepForward(); e.preventDefault(); }
  if (e.key === "ArrowLeft")  { charStepBackward(); e.preventDefault(); }
  if (e.key.toLowerCase() === "r") { charStepReset(); e.preventDefault(); }
});
</script>

</body>
</html>
